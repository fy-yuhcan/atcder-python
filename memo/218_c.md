# 問題番号(カテゴリ)
218C - Shapes　回転の座標変換

# 方針
- 図形は「# の座標リスト」で表す（2次元配列そのものではなく、点の集合として考える）
- 平行移動は「左上に寄せる normalize」で吸収する  
  - 最小の行・列 (min_i, min_j) を引いて、(i - min_i, j - min_j) にそろえる
- 回転は座標変換で扱う  
  - 時計回り90度回転: (i, j) → (j, N-1-i)
  - S の座標を 0°, 90°, 180°, 270° と4回回して、それぞれ normalize したものと
    T を normalize したものを比較する
- どれか1つでも一致したら "Yes"、全部ダメなら "No"

## カテゴリ
- 実装問題
- 座標変換（90度回転）
- 正規化（canonical form）
- 2次元グリッドの取り扱い

## 詰まったところ
- なぜ N-1-i になるか直感的に結びつかなかった
- 「縦横入れ替え」と「逆順」の2段階で分けて考える発想がなかった
- #の記号の座標のみを保存する発想
- 左上で固定する、正気化
- 「回転＋平行移動」をどうシミュレーションするかで考えてしまい、  
  手続き的に“動かす”発想から抜け出せなかった
- 平行移動を全探索しようとするとパターン数が多すぎるが、  
  「左上に寄せて形だけを見る」= normalize という考えにすぐ辿り着かなかった
- 90度回転の座標式 (i, j) → (j, N-1-i) の  
  「N-1-i」の意味がピンと来なかった  
  - 縦横が入れ替わる → new_i = j までは分かるが  
  - 「i を逆順にする」= 0..N-1 → N-1..0 → N-1-i という発想が弱かった

## 次に出たら
- まず小さい N でマスに (i,j) を書いて回転後の位置を手で確認する
- 「縦横が入れ替わる」→ `new_i` or `new_j` のどちらかを旧 `j` にする
- もう一方は「逆順かどうか」だけを考え、0..N-1 → N-1..0 の式を作る
- 四隅や数点で検算してからコードにする
- 正規化
- 2次元配列そのものではなく、「# の座標集合」で考えられないかを疑う
```python
# 正規化：左上を(0,0)に持ってくる
def normalize(cells):
    min_i = min(i for i, j in cells)
    min_j = min(j for i, j in cells)
    normalized = sorted((i - min_i, j - min_j) for i, j in cells)
    return normalized
```
- 90度のgrid回転
```python
# 90度回転(N-1-iはjの変換)
def rotate(cells):
    return [(j, N - 1 - i) for i, j in cells]
```
