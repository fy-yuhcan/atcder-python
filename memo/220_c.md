## 問題番号(カテゴリ)
ABC220 C - Long Sequence（数列 / 累積和っぽい / 数学）

## 方針
B は「A を 10^100 回並べた列」だけど、実際に並べる必要はなく、まず
```
S = sum(A) … A を 1周したときの和
```
を求める。
X を割り算して
```
q = X // S … A を何周分までは丸ごと足しても X を超えないか
```
を求める。

割り算の性質から `q * S ≤ X < (q+1) * S` が成り立つので、
最初の q 周では絶対に途中で X を超えない。
なので、最初の q 周は一気に飛ばす：
`count = q * N（ここまでに足した要素数）`
`current_sum = q * S（ここまでの合計）`
残りは A を 1周だけ、前から順に足していき、
```python
current_sum += A[i]

count += 1

current_sum > X 
```
になったところで count を出力して終了。
計算量は
`sum(A) で O(N)`

最後の 1 周走査で O(N)
→ 全体 O(N) で間に合う。

## カテゴリ
- 数列
- 累積和（1ブロックの和を使う）
- 商と余り（X // S と「ブロックを飛ばす」発想）
- 繰り返しパターンの圧縮（同じ列を何回も連結する問題）

## 詰まったところ

最初は
```python
for i in range(100000000):
    current_sum += A[i % N]
```
のように、円環にして1個ずつ足す方針を取った。

これは発想としては間違っていないが、
`実際の答えの項数 k は最大で 10^18 近くになりうる`

Python で 10^8 回ループでもきついのに、根本的には 10^18 回必要になるケースもある
→ 制約的に 1要素ずつループする方針自体がアウト。
「A を何回も繰り返して使う」ことは見えていたが、

### 「1 周分の和 S を使って、何周分か一気に飛ばす」

### 「割り算 X // S で飛ばして、残りだけ愚直にやる」
という発想に至らなかった。


また、
- q = X // S なので qS ≤ X < (q+1)S となり、q 周目の終点でもまだ X 以下だから、途中で超えることはありえない
- ＋ 次の 1 周は1要素ずつ足して current_sum > X をチェックしているので途中で超えた瞬間に必ず検知できる

## 次に出たら

同じ配列・文字列をたくさん連結する系の問題が出たら、まず：

### 「1ブロック（1周）の和 or 情報を先に計算する」

「ブロック単位で何回分まで丸ごと使えるか？」を割り算で考える（X // ブロック和）

「そこまでは一気に飛ばし、最後の1ブロックだけ愚直に走査する」
というパターンを真っ先に思い出す

制約を見たときに、

`N ≤ 10^5`

`X が 10^18 など大きい`
というときは、
- 答えのステップ数も 10^18 オーダーになる可能性がある
    - → 「1ステップずつシミュレートは絶対に無理」と判断するクセをつける。