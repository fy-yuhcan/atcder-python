# 問題番号(カテゴリ)
ABC219 C - neo-lexicographic Ordering（文字列・カスタムソート）
# 方針
- 通常の辞書順ではなく、「X が定める新しいアルファベット順」で文字列 S をソートする問題。
- まず文字 c に対して「X の世界での順位」を与える rank（または mapping）を作る。
    - rank = { c: i for i, c in enumerate(x) } のように、「文字 → 新しい順序（0〜25）」を対応付ける。

- 各単語 word について、
    word を [rank[ch] for ch in word] のように「順位の列」に変換し、
    それを sorted(..., key=...) の key として渡すことで、「X 基準の辞書順」でソートできる。

- あるいは別解として：
    - mapping[c] = chr(ord('a') + i) のように「Xの世界 → 通常の 'a'〜'z' の世界」への写像を作り、
    - 各 word を conversion(word, mapping) で「普通の辞書順世界の文字列」に変換し、

    - 変換後をキーにソートする、という方針も取れる。
## カテゴリ
文字列

カスタム辞書順（順序づけ）

ソート（key 指定 / マッピング）

## 詰まったところ

最初は「X を基準にしたソート」を、
自分で二分探索や挿入処理を書いて実装しようとしていた
どう比較するかが大事だとわかった

## 次に出たら
「通常と違う辞書順でソートしたい」という問題を見たら、まず：

文字 → 順位（int） の rank マップを作ることを最優先で考える。

そのうえで、次のどちらかの型にパターン化して解く：

sorted(s, key=lambda word: [rank[ch] for ch in word])

mapping[c] = chr(ord('a') + i) のように「別世界の文字列」に変換してからソートする

「ソートアルゴリズムを自作しようとしない」
→ 比較基準（key）だけを定義して、ソート処理は sorted / .sort() に任せる癖をつける。

lambda + key で詰まったら、

一度「普通の関数」に書き直して
def key_func(word): return [rank[ch] for ch in word]
の形にして考えることで、「何が key か」を明確にする