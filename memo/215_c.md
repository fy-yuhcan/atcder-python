# ABC215 C - Forbidden List（順列 / DFS・バックトラック）

# 方針

* やりたいことは：

  * 文字列 **S の「異なる並び替え（順列）」を全部列挙**
  * それを **辞書順に並べる**
  * **K 番目**を出力

* 解き方（DFS 重複スキップ）：

  1. `chars = sorted(s)` として、**文字をソートしておく**
     → 同じ文字が隣り合う形にする
  2. `used = [False] * n` を用意
     → 「このインデックスの文字をもう使ったか？」
  3. 再帰 `dfs(path)` を定義

     * `path` は「今までに選んだ文字の並び」
     * `len(path) == n` になったら 1 個完成 → `res.append("".join(path))`
  4. `dfs` の中では

     ```python
     for i in range(n):
         if used[i]:
             continue

         # ★重複スキップ
         if i > 0 and chars[i] == chars[i-1] and not used[i-1]:
             continue

         used[i] = True
         dfs(path + [chars[i]])
         used[i] = False
     ```

     * `used[i]` が True ならその枝では再利用しない
     * 「同じ文字が並んでいて、左側の同じ文字をまだ使っていないのに右側から使おうとしている」パターンを `continue` でスキップ
       → これで**同じ並びを二回作らない**
  5. `dfs([])` からスタート
  6. `res` はもう辞書順になっているので、そのまま `res[k-1]` を出力

* もう一つの素直解：

  * DFS で全順列を `res` に突っ込む
  * 最後に `uniq = sorted(set(res))`
  * `uniq[k-1]` を出力

---

## カテゴリ

* 全探索（順列全列挙）
* DFS / バックトラック（再帰 + `used`）
* 重複除去（`set` or 重複スキップ）
* 辞書順ソート

---

## 詰まったところ

* そもそも最初は
  **「全部の部分文字列を集める」方向に行ってしまった**

  * 問題は「並び替え（順列）」を求めているのに、`s[i:j]` で部分文字列を集めていた
* `permutations` のイメージ：
    **「S の文字をそのまま `permutations(s)` に渡せば、それが “全通りの並び替え”」**
* `set` の使い方：

  * `list(set(res))` だけで K 番目を取って WA
  * **`set` は順序を持たない**ので、

    * `sorted(set(res))` で**辞書順に並べ直さないと K 番目が定義できない**
* DFS 版で：

  * `used[i]` / `continue` / 再帰の戻りのイメージ

    * `used[i] = True` → その**再帰では**そのインデックスは二度使わない
    * `dfs(...)` から戻ったタイミングで `used[i] = False` → 次のパターンのためにリセット
* 重複スキップ版でのミス：

  * `chars = list(s)` のまま重複スキップ条件を書いていた
    → **ソートしてないと「同じ文字が隣り合う」と限らないから、判定が壊れる**
  * `if used[i]: continue` を入れ忘れたバージョンがあった
    → `used` が本来の「そのインデックスを二度使わない」という役割を果たしていなかった

---

## 次に出たら

* 「**S の文字を並び替えて K 番目**」「**異なる並び替え**」というキーワードが見えたら：

  * まず **「順列（permutations / DFS）＋重複除去＋辞書順」** を思い出す
  * 文字列長が小さい（N ≤ 8）なら「全列挙 OK」と判断
* 手順テンプレ：

  1. `chars = sorted(s)`
  2. `used = [False] * n`
  3. `dfs(path)` を書く：

     ```python
     def dfs(path):
         if len(path) == n:
             res.append("".join(path))
             return

         for i in range(n):
             if used[i]:
                 continue
             if i > 0 and chars[i] == chars[i-1] and not used[i-1]:
                 continue
             used[i] = True
             dfs(path + [chars[i]])
             used[i] = False
     ```
  4. `dfs([])` して `res[k-1]` を出す
  * `permutations` + `set` + `sorted` の素直実装で AC を取りに行く
