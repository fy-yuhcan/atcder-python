# ABC214 C - Distribution（伝播 / 最短到達時間）

# 方針
- 状態定義  
    - `ans[i]` : i 番目の人が **最初に** 宝石を持つ時刻（0-index）
- 初期値  
    - 各人は時刻 `T[i]` に外部から宝石を受け取る可能性がある  
    - よって最初は「直接もらう時刻」をそのまま採用  
      - `ans[i] = T[i]`
- 遷移（緩和）  
    - i 番の人が時刻 `ans[i]` に宝石を持っているとき  
      → 隣の `(i+1)%n` に `S[i]` 秒で渡せる  
    - 隣に届く候補時刻は `ans[i] + S[i]`  
      - `ans[next] = min(ans[next], ans[i] + S[i])`
- 円環の処理/mod演算
    - 配列は輪っか（`0→1→…→n-1→0→…`）なので、1 周では最速情報が全員に伝わらない可能性あり  
    - `2 * n` 回だけ「隣への伝播（緩和）」を繰り返せば、どのスタートからの情報も一周して行き渡る

## カテゴリ
- グラフ
    - 有向グラフ（i → i+1, n-1 → 0）
    - 複数始点・最短経路（multi-source shortest path）
- 1 次元 DP 的な緩和
    - `dp[next] = min(dp[next], dp[cur] + cost)` 型
- 円環構造（mod 演算）

## 詰まったところ
- 「これはグラフ / 最短経路の問題」と気づけなかった
    - 「宝石が伝播する」「最初に届く時刻」＝最短到達時間 という発想に至らなかった
- 配列 `a` に「インデックス」「時間」「'最後' マーカー」を混ぜてしまい、  
  何を表す配列か不明瞭だった（設計がブレた）
- ループ条件・添字のミス
    - `while count == len(a):` で一度もループに入らない
    - `for i in range(len(s)):` で `s[i+1]` を参照して範囲外
- 「T 全体を初期値にして、一括で `min` で緩和する」という発想ではなく、  
  「t[0] → t[1] → … を個別にシミュレートする」方向に行ってしまった

## 次に出たら
- 日本語でまず整理：
    - 「何かが隣に渡っていく（伝播する）」
    - 「最初に届く時刻 / 最短時間」を求めている  
  → **最短経路・緩和 DP** を疑う
- 状態を 1 配列で決める：
    - `ans[i] = i に宝石が最初に届く時刻`
- 初期値：
    - 「直接届く」情報があればそれで初期化  
      - `ans[i] = T[i]`
- 遷移：
    - 「誰から誰に」「何秒で」伝わるかを式にする  
      - `next = (i + 1) % n`  
      - `ans[next] = min(ans[next], ans[i] + S[i])`
- 円環なら：
    - 「ぐるっと何周すれば情報が行き渡るか？」を考える  
    - 迷ったら **とりあえず `2 * n` 回緩和** で OK

- テンプレコードイメージ：

```python
n = int(input())
S = list(map(int, input().split()))
T = list(map(int, input().split()))

# ans[i]: i番目の人が宝石を初めて持つ時刻
ans = T[:]  # まずは「外からもらう時刻」で初期化

for i in range(2 * n):         # 輪っかを2周ぶん緩和
    cur = i % n                # 今見ている人
    nxt = (cur + 1) % n        # 隣の人（時計回り）
    ans[nxt] = min(ans[nxt], ans[cur] + S[cur])

for x in ans:
    print(x)
```

mod演算(余剰演算を使ってループを作る)
```python
for i in range(2 * n):
    cur = i % n
    nxt = (cur + 1) % n
    ans[nxt] = min(ans[nxt], ans[cur] + S[cur])
```


